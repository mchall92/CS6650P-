Assignment Overview:

The purpose of this assignment is to create a client that can send map requests to a server, which can process the requests, using TCP or UDP protocols. When the client gets the request from users, it will convert it into a formatted message and send it to the server. Because the server knows the logic that the messages are formatted, the server can parse it and understand what the operation is. Both TCP and UDP follow a similar idea. However, because UDP does not require hand-shaking, it is possible that the message was not sent successfully, i.e., the message did not arrive at the server or the message body was broken. That is why we added a failure acknowledgment method in UDPHandler so that server can let the client know that the message was not delivered correctly. If the message was sent successfully, under both TCP and UDP protocols, our server will send this message back to the client. Based on this process, if the client did not receive any message from the server that the request had arrived and processed successfully, the client side would know that it is possible that the server did not receive the proper message. The client can then decide if that message should be sent again. The scope of this assignment is focused on how TCP and UDP process requests at the client-side as well as server-side. We also understand the fundamental difference between TCP and UDP.



Technical Impression:

As a student who has zero experience in the socket and real-world software development, my first reaction to the detail of how this project should be implemented was pure confusion. I have done assignment one which is building a server and a client that can communicate through TCP. However, building a Key-Value server client appears to be a different assignment. The first thing that needed to be considered was how the project should be structured. With the help and guidance from the Readme file provided by this class, I was able to gradually figure out the backbones of the classes. Because there is quite some similarity between how to process and send/receive requests with TCP and UDP protocols, we can first build an interface from the concrete class to implement. Further, for code re-use, it is advised that we built an abstract class for both TCP and UDP to extend. For the first part of the project- client, I started with TCP since I had some experience with it. I later followed the materials provided by the class to complete the UDP part. For the second part- server, following similar logic, I started with TCP handler. Apart from how the operation should be formatted and parsed as a string, I also got to decide how to handle different operations: put/get/delete with cleaner codes. Similar to the previous assignment, a response was also sent back to the client after the server received the request. UDP handler follows a similar concept; however, UDP does not guarantee that there is a server listening, we let the server report back to the client if the message body was broken. After building the crude structure of this project. I fine-tuned it by following additional requests in this project, including creating separate threads for TCP and UDP handlers and followed by numerous testing and debugging.

Another challenge for this project is to understand how Docker is used. With no experience in it, I read through several documentation and introductions for Docker and images. Follow each instruction on the Readme file, I was able to deploy the server and both clients, which can communicate at the same time under TCP and UDP protocols.